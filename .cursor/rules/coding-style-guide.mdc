---
description: Code Style Guide for Typescript
globs: 
alwaysApply: false
---
# Spring Bean Navigator 코딩 스타일 가이드

## TypeScript 코딩 표준

### 네이밍 컨벤션
- **클래스**: PascalCase (`SpringBeanDetector`, `CodeLensProvider`)
- **인터페이스**: PascalCase, 'I' 접두사 없이 (`BeanDefinition`, `NavigationService`)
- **변수/함수**: camelCase (`beanDefinitions`, `findBeanImplementation`)
- **상수**: SCREAMING_SNAKE_CASE (`MAX_SEARCH_DEPTH`, `DEFAULT_TIMEOUT`)
- **파일명**: kebab-case (`spring-bean-detector.ts`, `navigation-provider.ts`)
- **디렉토리**: kebab-case (`src/providers`, `src/utils`)

### 파일 구조 규칙
```
src/
├── extension.ts              # 메인 진입점
├── providers/               # VSCode 제공자들
│   ├── code-lens-provider.ts
│   ├── navigation-provider.ts
│   └── definition-provider.ts
├── detectors/              # Bean 탐지 로직
│   ├── autowired-detector.ts
│   ├── constructor-detector.ts
│   └── lombok-detector.ts
├── parsers/               # 파일 파싱 로직
│   ├── java-parser.ts
│   └── kotlin-parser.ts
├── models/               # 데이터 모델
│   ├── bean-definition.ts
│   └── injection-point.ts
└── utils/               # 유틸리티 함수
    ├── file-utils.ts
    └── logger.ts
```

## 코드 품질 기준

### 함수 작성 원칙
- **단일 책임**: 한 함수는 하나의 일만 수행
- **함수 길이**: 최대 50줄 이내
- **매개변수**: 최대 4개, 그 이상은 객체로 전달
- **리턴 타입**: 명시적으로 선언

```typescript
// ✅ 좋은 예
async function findBeanDefinition(
    className: string, 
    searchPath: string
): Promise<BeanDefinition | undefined> {
    // 구현
}

// ❌ 나쁜 예
function find(c, p, t, o) {
    // 구현
}
```

### 클래스 설계 원칙
- **생성자**: 의존성 주입 패턴 사용
- **메서드 순서**: public → protected → private
- **접근 제한자**: 명시적으로 선언

```typescript
export class SpringBeanDetector {
    constructor(
        private readonly fileSystem: FileSystemService,
        private readonly logger: Logger
    ) {}

    public async detectBeans(filePath: string): Promise<BeanDefinition[]> {
        // public 메서드
    }

    protected validateFilePath(path: string): boolean {
        // protected 메서드
    }

    private parseJavaFile(content: string): ParseResult {
        // private 메서드
    }
}
```

## 코드 포맷팅

### ESLint 설정 준수
- [eslint.config.mjs](mdc:eslint.config.mjs) 설정을 따름
- 저장 시 자동 포맷팅 활성화
- 빌드 전 린팅 통과 필수

### 주요 포맷팅 규칙
- **들여쓰기**: 4 spaces (탭 사용 금지)
- **세미콜론**: 필수
- **따옴표**: 단일 따옴표 사용
- **후행 쉼표**: 배열/객체에서 사용
- **줄 길이**: 최대 120자

```typescript
// ✅ 좋은 예
const beanConfig: BeanConfiguration = {
    className: 'UserService',
    injectionType: InjectionType.AUTOWIRED,
    fieldName: 'userRepository',
};

// ❌ 나쁜 예
const beanConfig:BeanConfiguration={className:"UserService",injectionType:InjectionType.AUTOWIRED,fieldName:"userRepository"}
```

## 주석 및 문서화

### JSDoc 표준
- 모든 public 메서드에 JSDoc 주석 필수
- 복잡한 로직에는 인라인 주석 추가

```typescript
/**
 * Spring Bean의 주입 지점을 탐지합니다.
 * 
 * @param filePath - 분석할 Java 파일 경로
 * @param content - 파일 내용
 * @returns Bean 주입 지점 배열
 * @throws {Error} 파일 파싱 실패 시
 */
public async detectInjectionPoints(
    filePath: string, 
    content: string
): Promise<InjectionPoint[]> {
    // 구현
}
```

### 주석 가이드라인
- **왜(Why)**를 설명하는 주석 선호
- **무엇(What)**을 설명하는 주석은 코드로 표현
- TODO/FIXME 주석에는 이슈 번호 포함

```typescript
// ✅ 좋은 예
// Lombok의 @RequiredArgsConstructor는 final 필드만 생성자에 포함
// 따라서 final 키워드가 있는 필드만 필터링
const finalFields = fields.filter(field => field.isFinal);

// ❌ 나쁜 예
// final 필드 필터링
const finalFields = fields.filter(field => field.isFinal);
```

## 에러 처리

### 예외 처리 원칙
- 구체적인 에러 타입 사용
- 에러 로깅 필수
- 사용자에게 친화적인 메시지 제공

```typescript
try {
    const beans = await this.detectBeans(filePath);
    return beans;
} catch (error) {
    this.logger.error(`Bean 탐지 실패: ${filePath}`, error);
    
    if (error instanceof SyntaxError) {
        throw new BeanDetectionError(`파일 구문 오류: ${error.message}`);
    }
    
    throw new BeanDetectionError('Bean 탐지 중 예상치 못한 오류가 발생했습니다.');
}
```

## 테스트 코드 스타일

### 테스트 구조
- **AAA 패턴**: Arrange, Act, Assert
- **명확한 테스트명**: `should_returnBeanDefinition_when_autowiredFieldExists`
- **단위 테스트**: 각 클래스별로 별도 테스트 파일

```typescript
describe('SpringBeanDetector', () => {
    describe('detectBeans', () => {
        it('should_returnBeanDefinition_when_autowiredFieldExists', async () => {
            // Arrange
            const detector = new SpringBeanDetector(mockFileSystem, mockLogger);
            const javaContent = '@Autowired private UserService userService;';
            
            // Act
            const result = await detector.detectBeans('test.java');
            
            // Assert
            expect(result).toHaveLength(1);
            expect(result[0].className).toBe('UserService');
        });
    });
});
```

## 성능 최적화 가이드

### 비동기 처리
- Promise보다 async/await 선호
- 병렬 처리 가능한 작업은 Promise.all 사용
- 대용량 파일 처리 시 스트림 활용

### 메모리 관리
- 불필요한 객체 참조 해제
- 대용량 데이터는 청크 단위로 처리
- WeakMap/WeakSet 활용으로 메모리 누수 방지

```typescript
// ✅ 병렬 처리
const [javaBeans, kotlinBeans] = await Promise.all([
    this.detectJavaBeans(javaFiles),
    this.detectKotlinBeans(kotlinFiles),
]);

// ❌ 순차 처리
const javaBeans = await this.detectJavaBeans(javaFiles);
const kotlinBeans = await this.detectKotlinBeans(kotlinFiles);
```
